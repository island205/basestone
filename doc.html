<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset='utf-8'>
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <meta name="viewport" content="width=640" />

        <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
        <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
        <link rel="stylesheet" href="stylesheets/doc.css" />

        <script type="text/javascript" src="javascripts/modernizr.js"></script>
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    </head>
    <body>
        <div class="main-content">
            <h3>欢迎使用Basestone</h3>

            <p><code>Basestone</code>是一个JavaScript常用的数据结构集合，包含了ECMASCript 6 中出现的新特性，比如<code>Map</code>、<code>Set</code>等新的数据结构以及一些方便的方法（<code>keys</code>、<code>values</code>）等等。</p>
            <p>往往我们在处理一些较为复杂的业务逻辑时，从<code>UI binding</code>开始写起，很多业务逻辑都写在事件的回调函数之中，这往往会造成代码的冗余和逻辑混乱，Basestone目的就是提供一个具有事件特性的常用数据结构，来帮助前端工程师，把界面操作和业务逻辑解耦出来，相当于提供一个数据<code>Model</code>中间层。</p>
            <section id="EventEmitter">
                <h4>EventEmitter</h4>
                <p><code>EventEmitter</code>为<code>Basestone</code>提供了一个简洁事件模型，接口完全兼容<code>Node</code>的<code>event.EventEmitter</code>。也可单独使用。</p>

                <pre><code>var target = {}
basestone.util.extend(target, basestone.EventEmitter.prototype)
// 现在 `target` 就可以绑定或触发事件了。</code></pre>

                <h6 id="addListener">AddListener(event, listener)</h6>
                <h6 id="on">on(event, listener)</h6>
                <p>注册一个名为<code>event</code>的事件监听器，监听器会依照执行的顺序依次执行。</p>
                <pre><code>// same as target.on
target.addEventListener('finish', function () {
    console.log("finished")
})</code></pre>

                <h6 id="once">once</h6>
                <p>注册一个名为<code>event</code>的事件监听器，且该监听器只执行一次。</p>
                <pre><code>target.once('done', function () {
    console.log("task is done")
})</code></pre>

                <h6 id="removeListener">removeListener(event, listener)</h6>
                <p>删除注册到<code>event</code>下面的事件监听器<code>listener</code></p>
                <pre><code>// like target.once
var
finishHandler = function () {
    console.log('task has finished')
    target.removeListener('finish', finishHandler)
}
target.on('finish', finishHandler)
</code></pre>

                <h6 id="removeAllListeners">removeAllListeners([event])</h6>
                <p>移除<code>event</code>下面所有监听器，如果没有传入<code>event</code>，移除所有的监听器。</p>

                <h6 id="setMaxListeners">setMaxListeners(n)</h6>
                <p>设置某个具体事件的最大监器个数，默认值为10。</p>


                <h6 id="listeners">listeners(event)</h6>
                <p>获取<code>event</code>下面的所有监听器。</p>


                <h6 id="emit">emit(event, [arg1, [arg2] ...])</h6>
                <p>触发事件<code>event</code>，可以传递一些参数。</p>
                <pre><code>target.on('finish', function (time) {
    console.log(time + ":finished")
}
target.emit('finish', Date.now)</code></pre>
            </section>

            <section id="value">
                <h4>value</h4>
                <p><code>value</code>可用来存储JavaScript中的基础类型数据，比如说<code>Number</code>、<code>String</code>等，可以对值进行修改，修改后会有相应的事件触发，可以提供<code>State</code>的功能。</p>
                <h6 id="value-contructor">contructor</h6>
                <p>可以用来构造一个<code>vlaue</code>，或者改变值。</p>
                <pre><code>var
step = backbone.value(1)
// 改到步骤2
step(2)
// 回到步骤1
step(1)

var
// st等于1
st = step()</code></pre>


                <h6 id="value-change">"change"</h6>
                <p>值改变时，会触发<code>change</code>事件。可以把散落在各个UI事件回调中的业务逻辑放到Model的回调中，组织起来，没有重复的代码。</p>
                <pre><code>step.on('change', function(st) {
    if (st === 1) {
        // 显示表单
    } else if (st === 2) {
        // 收起表单 显示结果
    } else {
        // 做点别的事
    }
})

// 表单中的submit
submit.on('click', function () {
    // 业务处理，成功后
    step(2)
})

back.on('click', function () {
    // 返回修改表单
    step(1)
})</code></pre>
            </section>
            
            <section>
                <h4 id="object">object</h4>
                <p>可以把<code>object</code>想象成JavaScript中Object对象的包装器，是用来管理一簇属性的，相当于Backbone中的Model类。属性值改变时，会触发相应的事件</p>

                <h6 id="object-constructor">constructor</h6>
                <pre><code>var task
task = backbone.object({
    content:'email to Mis',
    createTime:'Thu Jan 10 2013 14:36:11 GMT+0800 (中国标准时间)'
})
// "email to Mis"
task('content')

task('content', 'email to Mr')

// {content: 'email to Mr', createTime: 'Thu Jan 10 2013 14:36:11 GMT+0800 (中国标准时间)'}
task()</code></pre>


                <h6 id="object-keys">keys([iterator])</h6>
                <p>返回一个数组，包含所有的<code>key</code>，如果传了<code>iterator</code>，就迭代每一个<code>key</code></p>
                <pre><code>// ['content', 'createDate']
task.keys()

// email to Mr
// Thu Jan 10 2013 14:36:11 GMT+0800 (中国标准时间)
task.keys(function (key) {
    console.log(task(key))
})</code></pre>


                <h6 id="object-change">"change"</h6>
                <p>当属性的值变化时，会触发"<code>change</code>"事件。</p>
                <pre><code>task.on('change', function () {
    console.log('something changed')
})
task('content', 'email to Ms')</code></pre>


                <h6 id="object-change-key">"change:key"</h6>
                <p>可指定监听"<code>change</code>"事件的属性。</p>
                <pre>task.on('change:createDate', function (val) {
    console.log('Create Date change to ' + val)
})
task('createDate', new Date())<code></code></pre>
            </section>

            <section>
                <h4 id="array">array</h4>
                <p>可以把<code>array</code>想想成JavaSscript的Array对象的包装器，相当于Backbone中的Collection类，但没有那么强，用来管理一系列的项目。</p>


                <h6 id="array-constructor">constructor</h6>
                <p>可以传递一个数组作为初始化的项。</p>
                <pre><code>var memo
memo = basestone.array([task1, task2, task3])
memo(0)                     // task1
memo()                      // new Array containing task1, task2, task3
memo([task4, task5, task6]) // or just reset it</code></pre>


                <h6 id="array-prototype">Array.prototype</h6>
                <p><code>memo</code>对象上包含所有Array上常用的一些原型方法，包括新标准中加入进来的，大致分成三类：</p>
                <p>Mutator，即对内部有修改的方法：</p>
                <ul>
                    <li>pop</li>
                    <li>push</li>
                    <li>reverse</li>
                    <li>shift</li>
                    <li>sort</li>
                    <li>splice</li>
                    <li>unshit</li>
                </ul>
                <p>Accessor，即读取方法：</p>
                <ul>
                    <li>concat</li>
                    <li>join</li>
                    <li>slice</li>
                    <li>indexOf</li>
                    <li>lastIndexOf</li>
                </ul>
                <p>Iteration，迭代方法：</p>
                <ul>
                    <li>forEach</li>
                    <li>every</li>
                    <li>some</li>
                    <li>filter</li>
                    <li>map</li>
                    <li>reduce</li>
                    <li>reduceRight</li>
                </ul>
                <pre><code>var memo
memo = basestone.array([task1, task2, task3])
memo.pop() // task3
memo(memo.concat([task4, task5])) // memo now is [task1, task2, task3, task4, task5]
memo.forEach(function (task) {
    task.done = true
})
var
isDone = memo.every(function (task) {
    return task.done === true
})</code></pre>


                <h6 id="array-change-event">"change"</h6>
                <p>当Mutator方法被调用时，会对内部进行修改，此时会触发<code>"change"</code>事件。</p>
                <pre><code>memo.on('change', function () {
    console.log('memo is changed')
    // rerender UI by memo.forEach
})</code></pre>


                <h6 id="array-method-event">"[method]"</h6>
                <p>Mutator方法被调用时，会触发以相应方法名的事件。</p>
                <pre><code>memo.on('push', function () {
    // do something when there is item push in array
})</code></pre>
            </section>

            <section>
                <h4 id="set">set</h4>
                <p><code>Set</code>作为<code>ECMAScript 6</code>草案新添加的数据结构，有其自身的特点和需要。可用来管理一组值，而不用关系这组值的类型和内容，且每个值都是唯一的。<code>set</code>即是对它的实现。</p>
                <pre><code>var
store
store = basestone.set()

store.add(null)
store.add(undefined)
store.add(1)
// there are `null` `undefined` `1` in store

store.add(undefined)
// there are still `null` `undefined` `1` in store</code></pre>

                <h6 id="set-contructor">contructor</h6>
                <p>可传递一组初始值，初始值甚至可以是重复的，也可以什么都不传。</p>
                <pre><code>var
nameList
nameList = basestone.set(['Devid', 'Lucy', 'Lily', 'Derek', 'Lucy'])
// ['Devid', 'Lucy', 'Lily', 'Derek']
console.log(nameList.values())</code></pre>

                <h6 id="set-add">add</h6>
                <p>把更多的值添加到`Set`中，可以添加已经存在的值，只是`Set`本身没什么变化。</p>
                <pre><code>nameList.add('Island')
nameList.add('Devid')
// ['Devid', 'Lucy', 'Lily', 'Derek', 'Island']
console.log(nameList.values())</code></pre>

                <h6 id='set-remove'>remove</h6>
                <p>删除`Set`中存在的项，返回`true`，如果不存在删除项，则返回`false`。</p>
                <pre><code>nameList.remove('Island')
// `false`
console.log(nameList.remove('Man'))</code></pre>


                <h6 id="set-has">has</h6>
                <p>查看是否存在某个值。</p>
                <pre><code>// true
nameList.has('Devid')</code></pre>


                <h6 id="set-values">values</h6>
                <p>把所有的值作为一个数组返回，如果传入迭代器，则迭代所有的值。</p>
                <pre><code>nameList.values(function (name) {
    console.log(name + ' is here!')
})</code></pre>

                <h6 id="set-add-event">"add" event</h6>
                <p>有新值加入进来时，会触发"add"事件。</p>
                <pre><code>nameList.on('add', function (name) {
    console.log(name + ' is added!')
})
// 'Rose is added!'
nameList.add('Rose')</code></pre>
                
                <h6 id="set-remove-event">"remove" event</h6>
                <p>删除值时会触发"remove"事件。</p>
                <pre><code>nameList.on('remove', function (name) {
    console.log(name + ' is removed!')
})
// 'Devid is removed!'
nameList.remove('Devid')</code></pre>

                <h6 id="set-change-event">"change" event</h6>
                <p>不管是新增还是删除值，只要是对`Set`进行修改时，都会触发"change"事件。</p>
                <pre><code>nameLiist.on('change', function () {
    // rerender name list UI
})</code></pre>
            </section>

            <section>
                <h4 id="map">map</h4>
                <p><code>ECMAScript 6</code>还引入了另外一种数据结构——<code>Map</code>，与<code>Object</code>的不同之处在于，<code>Map</code>可以使用任何值作为<code>key</code>，而<code>Object</code>只能使用字符串作为<code>key</code>。而这里的<code>map</code>就是对其实现。</p>

                <h6 id="map-contructor">constructor</h6>
                <p>可传递一个二维数组，初始化一个<code>map</code></p>
                <pre><code>var
mp
mp = basestone.map([[undefined, undefined], [null, null], [document.body, document.body]])
// undefined
mp.get(undefined)
// or just
mp(undefined)</code></pre>

                <h6 id="map-set">set</h6>
                <p>添加或者修改某个键值对。</p>
                <pre><code>mp.set(document.body, 'document.body')
// 'document.body'
mp.get(document.body)</code></pre>

                <h6 id="map-remove">remove</h6>
                <p>删除某个键值对。</p>
                <pre><code>mp.remove(document.body)
// undefined
mp.get(document.body)</code></pre>

                <h6 id="map-get">get</h6>
                <p>获取值。</p>
                <pre><code>// null
mp.get(null)
// or just
mp(null)</code></pre>


                <h6 id="map-has">has</h6>
                <p>查看是否存在某个值。</p>
                <pre><code>// false
mp.has(document.body)</code></pre>


                <h6 id="map-keys">keys</h6>
                <p>把全部键作为一个数组返回，如果传递一个函数作为迭代器的话，会迭代每一个键。</p>
                <pre><code>// [undefined, null]
mp.keys()

// or iterate them
mp.keys(function (key) {
    // do with key
})</code></pre>

                <h6 id="map-values">values</h6>
                <p>与<code>keys</code>类似，不过迭代的是值。</p>
                <pre><code>// [undefined, null]
mp.values()

// or
mp.values(function (value) {
    // do with value
})</code></pre>

                <h6 id="map-remove-event">"remove" event</h6>
                <p>当删除键值对时，会出发该事件。</p>


                <h6 id="map-change-event">"change" event</h6>
                <p>当键值有改变时，会触发该事件。</p>
            </section>

        </div>
        <div class="sidebar">
            <br />
            <h1>Basestone <sub>v0.1.0</sub> </h1>
            <ul>
                <li>
                <h4><a href="#EventEmitter">EventEmitter</a></h4>
                <ul>
                    <li><a href="#addListener">addListener</a></li>
                    <li><a href="#on">on</a></li>
                    <li><a href="#once">once</a></li>
                    <li><a href="#removeListener">removeListener</a></li>
                    <li><a href="#removeAllListeners">removeAllListeners</a></li>
                    <li><a href="#setMaxListeners">setMaxListeners</a></li>
                    <li><a href="#listeners">listeners</a></li>
                    <li><a href="#emit">emit</a></li>
                </ul>
                </li>
                <li>
                <h4><a href="#value">value</a></h4>
                <ul>
                    <li><a href="#value-contructor">contructor</a></li>
                    <li><a href="#value-change">"change"</a></li>
                </ul>
                </li>
                <li>
                <h4><a href="#object">object</a></h4>
                <ul>
                    <li><a href="#oject-contructor">contructor</a></li>
                    <li><a href="#object-keys">keys</a></li>
                    <li><a href="#object-change">"change"</a></li>
                    <li><a href="#object-change-key">"change:key"</a></li>
                </ul>
                </li>
                <li>
                <h4><a href="#array">array</a></h4>
                <ul>
                    <li><a href="#array-constructor">contructor</a></li>
                    <li><a href="#array-prototype">Array.prototpye</a></li>
                    <li><a href="#array-change-event">"change"</a></li>
                    <li><a href="#array-method-event">"[method]"</a></li>
                </ul>
                </li>
                <li>
                <h4><a href="#set">set</a></h4>
                <ul>
                    <li><a href="#set-contructor">contructor</a></li>
                    <li><a href="#set-add">add</a></li>
                    <li><a href="#set-remove">remove</a></li>
                    <li><a href="#set-has">has</a></li>
                    <li><a href="#set-values">values</a></li>
                    <li><a href="#set-add-event">"add" event</a></li>
                    <li><a href="#set-remove-event">"remove" event</a></li>
                    <li><a href="#set-change-event">"change" event</a></li>
                </ul>
                </li>
                <li>
                <h4><a href="#map">map</a></h4>
                <ul>
                    <li><a href="#map-contructor">contructor</a></li>
                    <li><a href="#map-set">set</a></li>
                    <li><a href="#map-remove">remove</a></li>
                    <li><a href="#map-get">get</a></li>
                    <li><a href="#map-has">has</a></li>
                    <li><a href="#map-keys">keys</a></li>
                    <li><a href="#map-values">values</a></li>
                    <li><a href="#map-remove-event">"remove" event</a></li>
                    <li><a href="#map-change-event">"change" event</a></li>
                </ul>
                </li>
            </ul>
            <br />
            <br />
            <br />
        </div>
    </body>
</html>
